using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace WLanTest
{
    public class WlanInterop
    {
        #region p/invoke
        [DllImport("wlanapi.dll")]
        public static extern int WlanOpenHandle(
            [In] UInt32 clientVersion,
            [In, Out] IntPtr pReserved,
            [Out] out UInt32 negotiatedVersion,
            [Out] out IntPtr clientHandle);

        [DllImport("wlanapi.dll")]
        public static extern int WlanEnumInterfaces(
            [In] IntPtr clientHandle,
            [In, Out] IntPtr pReserved,
            [Out] out IntPtr ppInterfaceList);

        [DllImport("wlanapi.dll")]
        public static extern int WlanScan(
            [In] IntPtr clientHandle,
            [In, MarshalAs(UnmanagedType.LPStruct)] Guid interfaceGuid,
            [In] IntPtr pDot11Ssid,
            [In] IntPtr pIeData,
            [In, Out] IntPtr pReserved);

        [DllImport("wlanapi.dll")]
        public static extern int WlanGetAvailableNetworkList(
            [In] IntPtr clientHandle,
            [In, MarshalAs(UnmanagedType.LPStruct)] Guid interfaceGuid,
            [In] WlanGetAvailableNetworkFlags flags,
            [In, Out] IntPtr reservedPtr,
            [Out] out IntPtr availableNetworkListPtr);

        [DllImport("wlanapi.dll")]
        public static extern int WlanConnect(
            [In] IntPtr clientHandle,
            [In, MarshalAs(UnmanagedType.LPStruct)] Guid interfaceGuid,
            [In] ref WlanConnectionParameters connectionParameters,
            IntPtr pReserved);

        [DllImport("wlanapi.dll")]
        public static extern void WlanFreeMemory(IntPtr pMemory);

        public delegate void WlanNotificationCallbackDelegate(ref WlanNotificationData notificationData, IntPtr context);

        [DllImport("wlanapi.dll")]
        public static extern int WlanRegisterNotification(
            [In] IntPtr clientHandle,
            [In] WlanNotificationSource notifSource,
            [In] bool ignoreDuplicate,
            [In] WlanNotificationCallbackDelegate funcCallback,
            [In] IntPtr callbackContext,
            [In] IntPtr reserved,
            [Out] out WlanNotificationSource prevNotifSource);

        [DllImport("wlanapi.dll")]
        public static extern int WlanReasonCodeToString(
            [In] WlanReasonCode reasonCode,
            [In] int bufferSize,
            [In, Out] StringBuilder stringBuffer,
            IntPtr pReserved
        );
        #endregion

        #region Enum
        public static uint WLAN_API_VERSION_2_0 = 0x00000002;

        public enum WlanInterfaceState
        {
            NotReady = 0,
            Connected = 1,
            AdHocNetworkFormed = 2,
            Disconnecting = 3,
            Disconnected = 4,
            Associating = 5,
            Discovering = 6,
            Authenticating = 7
        }

        [Flags]
        public enum WlanGetAvailableNetworkFlags
        {
            IncludeAllAdhocProfiles = 0x00000001,
            IncludeAllManualHiddenProfiles = 0x00000002
        }
        #endregion

        #region Structures
        [StructLayout(LayoutKind.Sequential)]
        internal struct WlanInterfaceInfoList
        {
            public uint numberOfItems;
            public uint index;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct WlanInterfaceInfo
        {
            public Guid interfaceGuid;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
            public string interfaceDescription;
            public WlanInterfaceState isState;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct WlanAvailableNetworkList
        {
            public uint numberOfItems;
            public uint index;
        }

        [Flags]
        public enum WlanNotificationSource
        {
            None = 0,
            /// <summary>
            /// All notifications, including those generated by the 802.1X module.
            /// </summary>
            All = 0X0000FFFF,
            /// <summary>
            /// Notifications generated by the auto configuration module.
            /// </summary>
            ACM = 0X00000008,
            /// <summary>
            /// Notifications generated by MSM.
            /// </summary>
            MSM = 0X00000010,
            /// <summary>
            /// Notifications generated by the security module.
            /// </summary>
            Security = 0X00000020,
            /// <summary>
            /// Notifications generated by independent hardware vendors (IHV).
            /// </summary>
            IHV = 0X00000040
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct WlanNotificationData
        {
            /// <summary>
            /// Specifies where the notification comes from.
            /// </summary>
            /// <remarks>
            /// On Windows XP SP2, this field must be set to <see cref="WlanNotificationSource.None"/>, <see cref="WlanNotificationSource.All"/> or <see cref="WlanNotificationSource.ACM"/>.
            /// </remarks>
            public WlanNotificationSource notificationSource;
            /// <summary>
            /// Indicates the type of notification. The value of this field indicates what type of associated data will be present in <see cref="dataPtr"/>.
            /// </summary>
            public int notificationCode;
            /// <summary>
            /// Indicates which interface the notification is for.
            /// </summary>
            public Guid interfaceGuid;
            /// <summary>
            /// Specifies the size of <see cref="dataPtr"/>, in bytes.
            /// </summary>
            public int dataSize;
            /// <summary>
            /// Pointer to additional data needed for the notification, as indicated by <see cref="notificationCode"/>.
            /// </summary>
            public IntPtr dataPtr;

            /// <summary>
            /// Gets the notification code (in the correct enumeration type) according to the notification source.
            /// </summary>
            public object NotificationCode
            {
                get
                {
                    if (notificationSource == WlanNotificationSource.MSM)
                        return (WlanNotificationCodeMsm)notificationCode;
                    else if (notificationSource == WlanNotificationSource.ACM)
                        return (WlanNotificationCodeAcm)notificationCode;
                    else
                        return notificationCode;
                }

            }
        }

        public enum WlanNotificationCodeMsm
        {
            Associating = 1,
            Associated,
            Authenticating,
            Connected,
            RoamingStart,
            RoamingEnd,
            RadioStateChange,
            SignalQualityChange,
            Disassociating,
            Disconnected,
            PeerJoin,
            PeerLeave,
            AdapterRemoval,
            AdapterOperationModeChange
        }

        public enum WlanNotificationCodeAcm
        {
            AutoconfEnabled = 1,
            AutoconfDisabled,
            BackgroundScanEnabled,
            BackgroundScanDisabled,
            BssTypeChange,
            PowerSettingChange,
            ScanComplete,
            ScanFail,
            ConnectionStart,
            ConnectionComplete,
            ConnectionAttemptFail,
            FilterListChange,
            InterfaceArrival,
            InterfaceRemoval,
            ProfileChange,
            ProfileNameChange,
            ProfilesExhausted,
            NetworkNotAvailable,
            NetworkAvailable,
            Disconnecting,
            Disconnected,
            AdhocNetworkStateChange
        }

        [Flags]
        public enum WlanAvailableNetworkFlags
        {
            /// <summary>
            /// This network is currently connected.
            /// </summary>
            Connected = 0x00000001,
            /// <summary>
            /// There is a profile for this network.
            /// </summary>
            HasProfile = 0x00000002
        }

        public struct Dot11Ssid
        {
            /// <summary>
            /// The length, in bytes, of the <see cref="SSID"/> array.
            /// </summary>
            public uint SSIDLength;
            /// <summary>
            /// The SSID.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
            public byte[] SSID;
        }

        public enum Dot11BssType
        {
            /// <summary>
            /// Specifies an infrastructure BSS network.
            /// </summary>
            Infrastructure = 1,
            /// <summary>
            /// Specifies an independent BSS (IBSS) network.
            /// </summary>
            Independent = 2,
            /// <summary>
            /// Specifies either infrastructure or IBSS network.
            /// </summary>
            Any = 3
        }

        public enum WlanReasonCode
        {
            Success = 0,
            // general codes
            UNKNOWN = 0x10000 + 1,

            RANGE_SIZE = 0x10000,
            BASE = 0x10000 + RANGE_SIZE,

            // range for Auto Config
            //
            AC_BASE = 0x10000 + RANGE_SIZE,
            AC_CONNECT_BASE = (AC_BASE + RANGE_SIZE / 2),
            AC_END = (AC_BASE + RANGE_SIZE - 1),

            // range for profile manager
            // it has profile adding failure reason codes, but may not have 
            // connection reason codes
            //
            PROFILE_BASE = 0x10000 + (7 * RANGE_SIZE),
            PROFILE_CONNECT_BASE = (PROFILE_BASE + RANGE_SIZE / 2),
            PROFILE_END = (PROFILE_BASE + RANGE_SIZE - 1),

            // range for MSM
            //
            MSM_BASE = 0x10000 + (2 * RANGE_SIZE),
            MSM_CONNECT_BASE = (MSM_BASE + RANGE_SIZE / 2),
            MSM_END = (MSM_BASE + RANGE_SIZE - 1),

            // range for MSMSEC
            //
            MSMSEC_BASE = 0x10000 + (3 * RANGE_SIZE),
            MSMSEC_CONNECT_BASE = (MSMSEC_BASE + RANGE_SIZE / 2),
            MSMSEC_END = (MSMSEC_BASE + RANGE_SIZE - 1),

            // AC network incompatible reason codes
            //
            NETWORK_NOT_COMPATIBLE = (AC_BASE + 1),
            PROFILE_NOT_COMPATIBLE = (AC_BASE + 2),

            // AC connect reason code
            //
            NO_AUTO_CONNECTION = (AC_CONNECT_BASE + 1),
            NOT_VISIBLE = (AC_CONNECT_BASE + 2),
            GP_DENIED = (AC_CONNECT_BASE + 3),
            USER_DENIED = (AC_CONNECT_BASE + 4),
            BSS_TYPE_NOT_ALLOWED = (AC_CONNECT_BASE + 5),
            IN_FAILED_LIST = (AC_CONNECT_BASE + 6),
            IN_BLOCKED_LIST = (AC_CONNECT_BASE + 7),
            SSID_LIST_TOO_LONG = (AC_CONNECT_BASE + 8),
            CONNECT_CALL_FAIL = (AC_CONNECT_BASE + 9),
            SCAN_CALL_FAIL = (AC_CONNECT_BASE + 10),
            NETWORK_NOT_AVAILABLE = (AC_CONNECT_BASE + 11),
            PROFILE_CHANGED_OR_DELETED = (AC_CONNECT_BASE + 12),
            KEY_MISMATCH = (AC_CONNECT_BASE + 13),
            USER_NOT_RESPOND = (AC_CONNECT_BASE + 14),

            // Profile validation errors
            //
            INVALID_PROFILE_SCHEMA = (PROFILE_BASE + 1),
            PROFILE_MISSING = (PROFILE_BASE + 2),
            INVALID_PROFILE_NAME = (PROFILE_BASE + 3),
            INVALID_PROFILE_TYPE = (PROFILE_BASE + 4),
            INVALID_PHY_TYPE = (PROFILE_BASE + 5),
            MSM_SECURITY_MISSING = (PROFILE_BASE + 6),
            IHV_SECURITY_NOT_SUPPORTED = (PROFILE_BASE + 7),
            IHV_OUI_MISMATCH = (PROFILE_BASE + 8),
            // IHV OUI not present but there is IHV settings in profile
            IHV_OUI_MISSING = (PROFILE_BASE + 9),
            // IHV OUI is present but there is no IHV settings in profile
            IHV_SETTINGS_MISSING = (PROFILE_BASE + 10),
            // both/conflict MSMSec and IHV security settings exist in profile 
            CONFLICT_SECURITY = (PROFILE_BASE + 11),
            // no IHV or MSMSec security settings in profile
            SECURITY_MISSING = (PROFILE_BASE + 12),
            INVALID_BSS_TYPE = (PROFILE_BASE + 13),
            INVALID_ADHOC_CONNECTION_MODE = (PROFILE_BASE + 14),
            NON_BROADCAST_SET_FOR_ADHOC = (PROFILE_BASE + 15),
            AUTO_SWITCH_SET_FOR_ADHOC = (PROFILE_BASE + 16),
            AUTO_SWITCH_SET_FOR_MANUAL_CONNECTION = (PROFILE_BASE + 17),
            IHV_SECURITY_ONEX_MISSING = (PROFILE_BASE + 18),
            PROFILE_SSID_INVALID = (PROFILE_BASE + 19),
            TOO_MANY_SSID = (PROFILE_BASE + 20),

            // MSM network incompatible reasons
            //
            UNSUPPORTED_SECURITY_SET_BY_OS = (MSM_BASE + 1),
            UNSUPPORTED_SECURITY_SET = (MSM_BASE + 2),
            BSS_TYPE_UNMATCH = (MSM_BASE + 3),
            PHY_TYPE_UNMATCH = (MSM_BASE + 4),
            DATARATE_UNMATCH = (MSM_BASE + 5),

            // MSM connection failure reasons, to be defined
            // failure reason codes
            //
            // user called to disconnect
            USER_CANCELLED = (MSM_CONNECT_BASE + 1),
            // got disconnect while associating
            ASSOCIATION_FAILURE = (MSM_CONNECT_BASE + 2),
            // timeout for association
            ASSOCIATION_TIMEOUT = (MSM_CONNECT_BASE + 3),
            // pre-association security completed with failure
            PRE_SECURITY_FAILURE = (MSM_CONNECT_BASE + 4),
            // fail to start post-association security
            START_SECURITY_FAILURE = (MSM_CONNECT_BASE + 5),
            // post-association security completed with failure
            SECURITY_FAILURE = (MSM_CONNECT_BASE + 6),
            // security watchdog timeout
            SECURITY_TIMEOUT = (MSM_CONNECT_BASE + 7),
            // got disconnect from driver when roaming
            ROAMING_FAILURE = (MSM_CONNECT_BASE + 8),
            // failed to start security for roaming
            ROAMING_SECURITY_FAILURE = (MSM_CONNECT_BASE + 9),
            // failed to start security for adhoc-join
            ADHOC_SECURITY_FAILURE = (MSM_CONNECT_BASE + 10),
            // got disconnection from driver
            DRIVER_DISCONNECTED = (MSM_CONNECT_BASE + 11),
            // driver operation failed
            DRIVER_OPERATION_FAILURE = (MSM_CONNECT_BASE + 12),
            // Ihv service is not available
            IHV_NOT_AVAILABLE = (MSM_CONNECT_BASE + 13),
            // Response from ihv timed out
            IHV_NOT_RESPONDING = (MSM_CONNECT_BASE + 14),
            // Timed out waiting for driver to disconnect
            DISCONNECT_TIMEOUT = (MSM_CONNECT_BASE + 15),
            // An internal error prevented the operation from being completed.
            INTERNAL_FAILURE = (MSM_CONNECT_BASE + 16),
            // UI Request timed out.
            UI_REQUEST_TIMEOUT = (MSM_CONNECT_BASE + 17),
            // Roaming too often, post security is not completed after 5 times.
            TOO_MANY_SECURITY_ATTEMPTS = (MSM_CONNECT_BASE + 18),

            // MSMSEC reason codes
            //

            MSMSEC_MIN = MSMSEC_BASE,

            // Key index specified is not valid
            MSMSEC_PROFILE_INVALID_KEY_INDEX = (MSMSEC_BASE + 1),
            // Key required, PSK present
            MSMSEC_PROFILE_PSK_PRESENT = (MSMSEC_BASE + 2),
            // Invalid key length
            MSMSEC_PROFILE_KEY_LENGTH = (MSMSEC_BASE + 3),
            // Invalid PSK length
            MSMSEC_PROFILE_PSK_LENGTH = (MSMSEC_BASE + 4),
            // No auth/cipher specified
            MSMSEC_PROFILE_NO_AUTH_CIPHER_SPECIFIED = (MSMSEC_BASE + 5),
            // Too many auth/cipher specified
            MSMSEC_PROFILE_TOO_MANY_AUTH_CIPHER_SPECIFIED = (MSMSEC_BASE + 6),
            // Profile contains duplicate auth/cipher
            MSMSEC_PROFILE_DUPLICATE_AUTH_CIPHER = (MSMSEC_BASE + 7),
            // Profile raw data is invalid (1x or key data)
            MSMSEC_PROFILE_RAWDATA_INVALID = (MSMSEC_BASE + 8),
            // Invalid auth/cipher combination
            MSMSEC_PROFILE_INVALID_AUTH_CIPHER = (MSMSEC_BASE + 9),
            // 802.1x disabled when it's required to be enabled
            MSMSEC_PROFILE_ONEX_DISABLED = (MSMSEC_BASE + 10),
            // 802.1x enabled when it's required to be disabled
            MSMSEC_PROFILE_ONEX_ENABLED = (MSMSEC_BASE + 11),
            MSMSEC_PROFILE_INVALID_PMKCACHE_MODE = (MSMSEC_BASE + 12),
            MSMSEC_PROFILE_INVALID_PMKCACHE_SIZE = (MSMSEC_BASE + 13),
            MSMSEC_PROFILE_INVALID_PMKCACHE_TTL = (MSMSEC_BASE + 14),
            MSMSEC_PROFILE_INVALID_PREAUTH_MODE = (MSMSEC_BASE + 15),
            MSMSEC_PROFILE_INVALID_PREAUTH_THROTTLE = (MSMSEC_BASE + 16),
            // PreAuth enabled when PMK cache is disabled
            MSMSEC_PROFILE_PREAUTH_ONLY_ENABLED = (MSMSEC_BASE + 17),
            // Capability matching failed at network
            MSMSEC_CAPABILITY_NETWORK = (MSMSEC_BASE + 18),
            // Capability matching failed at NIC
            MSMSEC_CAPABILITY_NIC = (MSMSEC_BASE + 19),
            // Capability matching failed at profile
            MSMSEC_CAPABILITY_PROFILE = (MSMSEC_BASE + 20),
            // Network does not support specified discovery type
            MSMSEC_CAPABILITY_DISCOVERY = (MSMSEC_BASE + 21),
            // Passphrase contains invalid character
            MSMSEC_PROFILE_PASSPHRASE_CHAR = (MSMSEC_BASE + 22),
            // Key material contains invalid character
            MSMSEC_PROFILE_KEYMATERIAL_CHAR = (MSMSEC_BASE + 23),
            // Wrong key type specified for the auth/cipher pair
            MSMSEC_PROFILE_WRONG_KEYTYPE = (MSMSEC_BASE + 24),
            // "Mixed cell" suspected (AP not beaconing privacy, we have privacy enabled profile)
            MSMSEC_MIXED_CELL = (MSMSEC_BASE + 25),
            // Auth timers or number of timeouts in profile is incorrect
            MSMSEC_PROFILE_AUTH_TIMERS_INVALID = (MSMSEC_BASE + 26),
            // Group key update interval in profile is incorrect
            MSMSEC_PROFILE_INVALID_GKEY_INTV = (MSMSEC_BASE + 27),
            // "Transition network" suspected, trying legacy 802.11 security
            MSMSEC_TRANSITION_NETWORK = (MSMSEC_BASE + 28),
            // Key contains characters which do not map to ASCII
            MSMSEC_PROFILE_KEY_UNMAPPED_CHAR = (MSMSEC_BASE + 29),
            // Capability matching failed at profile (auth not found)
            MSMSEC_CAPABILITY_PROFILE_AUTH = (MSMSEC_BASE + 30),
            // Capability matching failed at profile (cipher not found)
            MSMSEC_CAPABILITY_PROFILE_CIPHER = (MSMSEC_BASE + 31),

            // Failed to queue UI request
            MSMSEC_UI_REQUEST_FAILURE = (MSMSEC_CONNECT_BASE + 1),
            // 802.1x authentication did not start within configured time 
            MSMSEC_AUTH_START_TIMEOUT = (MSMSEC_CONNECT_BASE + 2),
            // 802.1x authentication did not complete within configured time
            MSMSEC_AUTH_SUCCESS_TIMEOUT = (MSMSEC_CONNECT_BASE + 3),
            // Dynamic key exchange did not start within configured time
            MSMSEC_KEY_START_TIMEOUT = (MSMSEC_CONNECT_BASE + 4),
            // Dynamic key exchange did not succeed within configured time
            MSMSEC_KEY_SUCCESS_TIMEOUT = (MSMSEC_CONNECT_BASE + 5),
            // Message 3 of 4 way handshake has no key data (RSN/WPA)
            MSMSEC_M3_MISSING_KEY_DATA = (MSMSEC_CONNECT_BASE + 6),
            // Message 3 of 4 way handshake has no IE (RSN/WPA)
            MSMSEC_M3_MISSING_IE = (MSMSEC_CONNECT_BASE + 7),
            // Message 3 of 4 way handshake has no Group Key (RSN)
            MSMSEC_M3_MISSING_GRP_KEY = (MSMSEC_CONNECT_BASE + 8),
            // Matching security capabilities of IE in M3 failed (RSN/WPA)
            MSMSEC_PR_IE_MATCHING = (MSMSEC_CONNECT_BASE + 9),
            // Matching security capabilities of Secondary IE in M3 failed (RSN)
            MSMSEC_SEC_IE_MATCHING = (MSMSEC_CONNECT_BASE + 10),
            // Required a pairwise key but AP configured only group keys
            MSMSEC_NO_PAIRWISE_KEY = (MSMSEC_CONNECT_BASE + 11),
            // Message 1 of group key handshake has no key data (RSN/WPA)
            MSMSEC_G1_MISSING_KEY_DATA = (MSMSEC_CONNECT_BASE + 12),
            // Message 1 of group key handshake has no group key
            MSMSEC_G1_MISSING_GRP_KEY = (MSMSEC_CONNECT_BASE + 13),
            // AP reset secure bit after connection was secured
            MSMSEC_PEER_INDICATED_INSECURE = (MSMSEC_CONNECT_BASE + 14),
            // 802.1x indicated there is no authenticator but profile requires 802.1x
            MSMSEC_NO_AUTHENTICATOR = (MSMSEC_CONNECT_BASE + 15),
            // Plumbing settings to NIC failed
            MSMSEC_NIC_FAILURE = (MSMSEC_CONNECT_BASE + 16),
            // Operation was cancelled by caller
            MSMSEC_CANCELLED = (MSMSEC_CONNECT_BASE + 17),
            // Key was in incorrect format 
            MSMSEC_KEY_FORMAT = (MSMSEC_CONNECT_BASE + 18),
            // Security downgrade detected
            MSMSEC_DOWNGRADE_DETECTED = (MSMSEC_CONNECT_BASE + 19),
            // PSK mismatch suspected
            MSMSEC_PSK_MISMATCH_SUSPECTED = (MSMSEC_CONNECT_BASE + 20),
            // Forced failure because connection method was not secure
            MSMSEC_FORCED_FAILURE = (MSMSEC_CONNECT_BASE + 21),
            // ui request couldn't be queued or user pressed cancel
            MSMSEC_SECURITY_UI_FAILURE = (MSMSEC_CONNECT_BASE + 22),

            MSMSEC_MAX = MSMSEC_END
        }

        public enum Dot11PhyType : uint
        {
            /// <summary>
            /// Specifies an unknown or uninitialized PHY type.
            /// </summary>
            Unknown = 0,
            /// <summary>
            /// Specifies any PHY type.
            /// </summary>
            Any = Unknown,
            /// <summary>
            /// Specifies a frequency-hopping spread-spectrum (FHSS) PHY. Bluetooth devices can use FHSS or an adaptation of FHSS.
            /// </summary>
            FHSS = 1,
            /// <summary>
            /// Specifies a direct sequence spread spectrum (DSSS) PHY.
            /// </summary>
            DSSS = 2,
            /// <summary>
            /// Specifies an infrared (IR) baseband PHY.
            /// </summary>
            IrBaseband = 3,
            /// <summary>
            /// Specifies an orthogonal frequency division multiplexing (OFDM) PHY. 802.11a devices can use OFDM.
            /// </summary>
            OFDM = 4,
            /// <summary>
            /// Specifies a high-rate DSSS (HRDSSS) PHY.
            /// </summary>
            HRDSSS = 5,
            /// <summary>
            /// Specifies an extended rate PHY (ERP). 802.11g devices can use ERP.
            /// </summary>
            ERP = 6,
            /// <summary>
            /// Specifies the start of the range that is used to define PHY types that are developed by an independent hardware vendor (IHV).
            /// </summary>
            IHV_Start = 0x80000000,
            /// <summary>
            /// Specifies the end of the range that is used to define PHY types that are developed by an independent hardware vendor (IHV).
            /// </summary>
            IHV_End = 0xffffffff
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct WlanAvailableNetwork
        {
            /// <summary>
            /// Contains the profile name associated with the network.
            /// If the network doesn't have a profile, this member will be empty.
            /// If multiple profiles are associated with the network, there will be multiple entries with the same SSID in the visible network list. Profile names are case-sensitive.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
            public string profileName;
            /// <summary>
            /// Contains the SSID of the visible wireless network.
            /// </summary>
            public Dot11Ssid dot11Ssid;
            /// <summary>
            /// Specifies whether the network is infrastructure or ad hoc.
            /// </summary>
            public Dot11BssType dot11BssType;
            /// <summary>
            /// Indicates the number of BSSIDs in the network.
            /// </summary>
            public uint numberOfBssids;
            /// <summary>
            /// Indicates whether the network is connectable or not.
            /// </summary>
            public bool networkConnectable;
            /// <summary>
            /// Indicates why a network cannot be connected to. This member is only valid when <see cref="networkConnectable"/> is <c>false</c>.
            /// </summary>
            public WlanReasonCode wlanNotConnectableReason;
            /// <summary>
            /// The number of PHY types supported on available networks.
            /// The maximum value of this field is 8. If more than 8 PHY types are supported, <see cref="morePhyTypes"/> must be set to <c>true</c>.
            /// </summary>
            private uint numberOfPhyTypes;
            /// <summary>
            /// Contains an array of <see cref="Dot11PhyType"/> values that represent the PHY types supported by the available networks.
            /// When <see cref="numberOfPhyTypes"/> is greater than 8, this array contains only the first 8 PHY types.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
            private Dot11PhyType[] dot11PhyTypes;
            /// <summary>
            /// Gets the <see cref="Dot11PhyType"/> values that represent the PHY types supported by the available networks.
            /// </summary>

            /// <summary>
            /// Specifies if there are more than 8 PHY types supported.
            /// When this member is set to <c>true</c>, an application must call <see cref="WlanClient.WlanInterface.GetNetworkBssList"/> to get the complete list of PHY types.
            /// <see cref="WlanBssEntry.phyId"/> contains the PHY type for an entry.
            /// </summary>
            public bool morePhyTypes;
            /// <summary>
            /// A percentage value that represents the signal quality of the network.
            /// This field contains a value between 0 and 100.
            /// A value of 0 implies an actual RSSI signal strength of -100 dbm.
            /// A value of 100 implies an actual RSSI signal strength of -50 dbm.
            /// You can calculate the RSSI signal strength value for values between 1 and 99 using linear interpolation.
            /// </summary>
            public uint wlanSignalQuality;
            /// <summary>
            /// Indicates whether security is enabled on the network.
            /// </summary>
            public bool securityEnabled;
            /// <summary>
            /// Indicates the default authentication algorithm used to join this network for the first time.
            /// </summary>
            public uint dot11DefaultAuthAlgorithm;
            /// <summary>
            /// Indicates the default cipher algorithm to be used when joining this network.
            /// </summary>
            public uint dot11DefaultCipherAlgorithm;
            /// <summary>
            /// Contains various flags for the network.
            /// </summary>
            public WlanAvailableNetworkFlags flags;
            /// <summary>
            /// Reserved for future use. Must be set to NULL.
            /// </summary>
            uint reserved;

            public string GetStringForSSID()
            {
                return Encoding.ASCII.GetString(dot11Ssid.SSID, 0, (int)dot11Ssid.SSIDLength);
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct WlanConnectionParameters
        {
            /// <summary>
            /// Specifies the mode of connection.
            /// </summary>
            public WlanConnectionMode wlanConnectionMode;
            /// <summary>
            /// Specifies the profile being used for the connection.
            /// The contents of the field depend on the <see cref="wlanConnectionMode"/>:
            /// <list type="table">
            /// <listheader>
            /// <term>Value of <see cref="wlanConnectionMode"/></term>
            /// <description>Contents of the profile string</description>
            /// </listheader>
            /// <item>
            /// <term><see cref="WlanConnectionMode.Profile"/></term>
            /// <description>The name of the profile used for the connection.</description>
            /// </item>
            /// <item>
            /// <term><see cref="WlanConnectionMode.TemporaryProfile"/></term>
            /// <description>The XML representation of the profile used for the connection.</description>
            /// </item>
            /// <item>
            /// <term><see cref="WlanConnectionMode.DiscoverySecure"/>, <see cref="WlanConnectionMode.DiscoveryUnsecure"/> or <see cref="WlanConnectionMode.Auto"/></term>
            /// <description><c>null</c></description>
            /// </item>
            /// </list>
            /// </summary>
            [MarshalAs(UnmanagedType.LPWStr)]
            public string profile;
            /// <summary>
            /// Pointer to a <see cref="Dot11Ssid"/> structure that specifies the SSID of the network to connect to.
            /// This field is optional. When set to <c>null</c>, all SSIDs in the profile will be tried.
            /// This field must not be <c>null</c> if <see cref="wlanConnectionMode"/> is set to <see cref="WlanConnectionMode.DiscoverySecure"/> or <see cref="WlanConnectionMode.DiscoveryUnsecure"/>.
            /// </summary>
            public IntPtr dot11SsidPtr;
            /// <summary>
            /// Pointer to a <see cref="Dot11BssidList"/> structure that contains the list of basic service set (BSS) identifiers desired for the connection.
            /// </summary>
            /// <remarks>
            /// On Windows XP SP2, must be set to <c>null</c>.
            /// </remarks>
            public IntPtr desiredBssidListPtr;
            /// <summary>
            /// A <see cref="Dot11BssType"/> value that indicates the BSS type of the network. If a profile is provided, this BSS type must be the same as the one in the profile.
            /// </summary>
            public Dot11BssType dot11BssType;
            /// <summary>
            /// Specifies ocnnection parameters.
            /// </summary>
            /// <remarks>
            /// On Windows XP SP2, must be set to 0.
            /// </remarks>
            public WlanConnectionFlags flags;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct WlanConnectionNotificationData
        {
            /// <remarks>
            /// On Windows XP SP 2, only <see cref="WlanConnectionMode.Profile"/> is supported.
            /// </remarks>
            public WlanConnectionMode wlanConnectionMode;
            /// <summary>
            /// The name of the profile used for the connection. Profile names are case-sensitive.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
            public string profileName;
            /// <summary>
            /// The SSID of the association.
            /// </summary>
            public Dot11Ssid dot11Ssid;
            /// <summary>
            /// The BSS network type.
            /// </summary>
            public Dot11BssType dot11BssType;
            /// <summary>
            /// Indicates whether security is enabled for this connection.
            /// </summary>
            public bool securityEnabled;
            /// <summary>
            /// Indicates the reason for an operation failure.
            /// This field has a value of <see cref="WlanReasonCode.Success"/> for all connection-related notifications except <see cref="WlanNotificationCodeAcm.ConnectionComplete"/>.
            /// If the connection fails, this field indicates the reason for the failure.
            /// </summary>
            public WlanReasonCode wlanReasonCode;
            /// <summary>
            /// This field contains the XML presentation of the profile used for discovery, if the connection succeeds.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 1)]
            public string profileXml;
        }

        [Flags]
        public enum WlanConnectionFlags
        {
            /// <summary>
            /// Connect to the destination network even if the destination is a hidden network. A hidden network does not broadcast its SSID. Do not use this flag if the destination network is an ad-hoc network.
            /// <para>If the profile specified by <see cref="WlanConnectionParameters.profile"/> is not <c>null</c>, then this flag is ignored and the nonBroadcast profile element determines whether to connect to a hidden network.</para>
            /// </summary>
            HiddenNetwork = 0x00000001,
            /// <summary>
            /// Do not form an ad-hoc network. Only join an ad-hoc network if the network already exists. Do not use this flag if the destination network is an infrastructure network.
            /// </summary>
            AdhocJoinOnly = 0x00000002,
            /// <summary>
            /// Ignore the privacy bit when connecting to the network. Ignoring the privacy bit has the effect of ignoring whether packets are encryption and ignoring the method of encryption used. Only use this flag when connecting to an infrastructure network using a temporary profile.
            /// </summary>
            IgnorePrivacyBit = 0x00000004,
            /// <summary>
            /// Exempt EAPOL traffic from encryption and decryption. This flag is used when an application must send EAPOL traffic over an infrastructure network that uses Open authentication and WEP encryption. This flag must not be used to connect to networks that require 802.1X authentication. This flag is only valid when <see cref="WlanConnectionParameters.wlanConnectionMode"/> is set to <see cref="WlanConnectionMode.TemporaryProfile"/>. Avoid using this flag whenever possible.
            /// </summary>
            EapolPassthrough = 0x00000008
        }

        public enum WlanConnectionMode
        {
            /// <summary>
            /// A profile will be used to make the connection.
            /// </summary>
            Profile = 0,
            /// <summary>
            /// A temporary profile will be used to make the connection.
            /// </summary>
            TemporaryProfile,
            /// <summary>
            /// Secure discovery will be used to make the connection.
            /// </summary>
            DiscoverySecure,
            /// <summary>
            /// Unsecure discovery will be used to make the connection.
            /// </summary>
            DiscoveryUnsecure,
            /// <summary>
            /// A connection will be made automatically, generally using a persistent profile.
            /// </summary>
            Auto,
            /// <summary>
            /// Not used.
            /// </summary>
            Invalid
        }
        #endregion
    }
}
